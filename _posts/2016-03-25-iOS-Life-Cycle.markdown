---
layout: post
title:  "[iOS] Life Cycle"
date:   2016-03-25 03:00:00
tag:
- iOS
- Life Cycle
- AppDelegate
- Application
- View Controller
- Build Setting
ios: true
---

# The Structure of an App
![key objs in an iOS app](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Art/core_objects_2x.png)

|Object|Description|
|-|-|
|**UIApplication** object|UIApplication 객체는 다른 high-level 앱의 액션이나 이벤트 루프를 관리합니다. 또한, key app transitions와 어떤 특정 이벤트들(push notification 받기)을 그것의 delegate에게 보내줍니다. subclassing 하지말고 UIApplication 객체를 있는 그대로 사용하세요. |
|**App delegate** object|App delegate는 커스텀 코드의 심장입니다. 이 객체는 앱의 초기화, 상태 변화, 많은 high-level의 앱 이벤트들을 위해 UIApplication 과 함께 일합니다. 이 객체는 또한, 모든 앱에 꼭 존재하는 객체로써, 초기 data structure를 구성하는데 종종 사용됩ㄴ디ㅏ. |
|Documents and data model objects|*Data Model object*는 앱의 내용을 저장하고, 앱을 특정짓습니다. 예를 들어, 은행 앱은 금융 트랜젝션에 대한 데이터베이스를 포함할 것이고, 페인팅 앱은 이미지 오브젝트나 이미지 생성을 하는 drawing commands의 순서들을 저장할 것입니다.<br/>앱은 이 document object(UIDocument의 커스텀 subclass)를 사용해서, 데이터 모델 객체들을 관리합니다. Document 객체들은 꼭 필요하지는 않지만, 하나의 파일이나 파일 패키지에 속한 그룹 데이터들을 제공하는데 편리합니다.|
|View Controller objects|View Controller 객체들은 화면에 나타나는 앱의 내용들의 presentation을 관리합니다. View Controller는 한개의 뷰와 subview들의 컬렉션을 관리합니다. 그것이 presented되면, view controller는 뷰를 보이게 만들고, 앱의 창에 그것을 설치(installing)합니다.<br/> **UIViewController class **는 모든 View Contoller object의 base입니다. 이 클래스는 뷰를 로딩하고, 그것을 보여주고, 회전하는 등의 기본적인 기능을 제공합니다. UIKIt과 다른 프레임워크들은 부가적인 view controller 클래스들을 정의하여서, 이미지 피커나 탭바 인터페이스, 네비게이션 인터페이스와 같은 표준 시스템 인터페이스를 구현하는데 사용합니다.|
|**UIWindow** object|UIWindow 객체는 화면에 하나 이상의 뷰들을 표현합니다. 대부분의 앱들은 내용을 메인 스크린에 표현하는 하나의 window를 가지고 있지만, 외부의 디스펠레이에서 표현되는 부가적인 윈도우를 가질 수도 있습니다.<br/>앱의 내용을 바꾸기 위해서는 view controller를 사용해서 그에 부합하는 윈도우에 view를 바꿔줍니다. window 자체를 절대로 바꿔서는 안됩니다. hosting views 뿐만 아니라, windows는 UIApplication 객체와 함께 뷰와 뷰 컨트롤러에게 이벤트를 전달해줍니다.|
|**View objects**, **control objects**, and layer objects|뷰와 컨트롤러는 시각적인 표현을 제공합니다. *뷰*는 지정된 직사각형의 공간에 내용을 그리고, 그 공간안의 이벤트들에 반응하는 객체입니다. *컨트롤러*는 버튼이나 텍스트 필드, 스위치 토글과 같은 친숙한 인터페이스 오브젝트들을 구현하는 목적의 특별한 타입의 뷰입니다.<br/> UIKit 프레임워크는 매우 다양한 타입의 컨텐츠를 보여주기 위해서 표준 뷰를 제공하고 있습니다. **UIVIew**를 subclassing 함으로써, 자신만의 custom view 를 만들 수도 있습니다.<br/> 뷰와 컨트롤러를 결합시키는 것 뿐만 아니라, 앱은 Core Animatio layers를 뷰와 컨트롤 hierachies로 결합시킬 수도 있습니다. *Layer 객체*들은 사실 시각적 컨텐츠를 표현하는 데이터 객체들입니다. 뷰들은 scenes 뒤에서 컨텐츠를 렌더링 하기 위해서 layer객체들을 사용합니다. 역시나, 복잡한 애니메이션을 구현하기 위해서 custom layer객체들을 인터페이스에 더할 수 있습니다.|

# THe Main Run Loop
![Processing events in the main run loop](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Art/event_draw_cycle_a_2x.png)
|Event type|Delivered to...|Notes|
|-|-|-|
|Touch|The view object in which the event occurred|Views are responder objects. Any touch events not handled by the view are forwarded down the responder chain for processing.|
|Remote control<br/>Shake motion events|First responder object|	
Remote control events are for controlling media playback and are generated by headphones and other accessories.|
|Accelerometer<br/>Magnetometer<br/>Gyroscope|The object you designate|Events related to the accelerometer, magnetometer, and gyroscope hardware are delivered to the object you designate.|
|Location|The object you designate|You register to receive location events using the Core Location framework. For more information about using Core Location, see Location and Maps Programming Guide.|
|Redraw|The view that needs the update|Redraw events do not involve an event object but are simply calls to the view to draw itself. The drawing architecture for iOS is described in Drawing and Printing Guide for iOS.|

# Execution States for Apps

![State changes in an iOS app](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Art/high_level_flow_2x.png)

<table class="graybox" border="0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number">Table 2-3</strong>&nbsp;&nbsp;App states</caption><tbody><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>State</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr><tr><td scope="row"><p>Not running</p></td><td><p>The app has not been launched or was running but was terminated by the system. </p></td></tr><tr><td scope="row"><p>Inactive</p></td><td><p>The app is running in the foreground but is currently not receiving events. (It may be executing other code though.) An app usually stays in this state only briefly as it transitions to a different state.</p></td></tr><tr><td scope="row"><p>Active</p></td><td><p>The app is running in the foreground and is receiving events. This is the normal mode for foreground apps.</p></td></tr><tr><td scope="row"><p>Background</p></td><td><p>The app is in the background and executing code. Most apps enter this state briefly on their way to being suspended. However, an app that requests extra execution time may remain in this state for a period of time. In addition, an app being launched directly into the background enters this state instead of the inactive state. For information about how to execute code while in the background, see <span class="content_text"><a href="../BackgroundExecution/BackgroundExecution.html#//apple_ref/doc/uid/TP40007072-CH4-SW1" data-renderer-version="1" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/_5&quot;;return this.s_oc?this.s_oc(e):true">Background Execution</a></span>. </p></td></tr><tr><td scope="row"><p>Suspended</p></td><td><p>The app is in the background but is not executing code. The system moves apps to this state automatically and does not notify them before doing so. While suspended, an app remains in memory but does not execute any code.</p><p>When a low-memory condition occurs, the system may purge suspended apps without notice to make more space for the foreground app. </p></td></tr></tbody></table>


# iOS Application Life Cycle

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
 => 어플리케이션이 처음 실행될 때. (처음 메모리상에 올라가게 될 때를 말함) 

- (void)applicationDidBecomeActive:(UIApplication *)application
 => 어플리케이션이 활성화 될 때, 
  즉 didFinishLaunchingWithOption 호출 직후, 어플리케이션이 백그라운드로 돌아갔다가 다시 불러질 때 호출

- (void)applicationWillResignActive:(UIApplication *)application
 => 어플리케이션이 백그라운드로 들어가기 직전(홈버튼을 누른 직후)에 호출 됨

- (void)applicationDidEnterBackground:(UIApplication *)application
 => 어플리케이션이 백그라운드로 완전히 들어갔을 때 호출됨

- (void)applicationWillEnterForeground:(UIApplication *)application
 => 어플리케이션이 다시 활성되 되기 직전에 호출됨
    (백그라운드 상에서 다시 어플리케이션이 활성되 되면 willEnterForeground 호출 후 applicationDidBecomeActive 호출)

- (void)applicationWillTerminate:(UIApplication *)application 
 => 어플리케이션이 완전히 종료되기 직전에 호출 됨
 
# iOS View Controller Life Cycle

- (void)loadView
뷰 컨트롤러에 보여지는 컨트롤러들을 생성하거나 추가할 때 적당한 부분 

- (void)viewWillAppear:(BOOL)animated
뷰 컨트롤러가 사용자에게 보여지기 직전에 호출(복수 호출 가능) 
loadView 다음에 호출 됨 

- (void)viewDidLoad
viewWillAppear 다음에 호출 됨 (단 한번만 호출됨) 

- (void)viewDidAppear:(BOOL)animated
viewDidLoad 다음에 호출 됨(복수 호출 가능)

- (void)viewWillDisappear:(BOOL)animated
해당 뷰컨트롤러가 사라지기 직전에 호출됨  

- (void)viewDidUnload
viewWillDisappear 이후에 호출됨

- (void)viewDidDisappear:(BOOL)animated
viewDidUnload 이후에 호출됨